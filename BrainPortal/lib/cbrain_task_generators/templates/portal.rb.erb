
#
# CBRAIN Project
#
# Copyright (C) 2008-2012
# The Royal Institution for the Advancement of Learning
# McGill University
#
# This program is free software: you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation, either version 3 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program.  If not, see <http://www.gnu.org/licenses/>.
#

# NOTE: This is a working template generated from a descriptor:
# [Schema]         <%= schema['id'] %>
# [Schema version] <%= descriptor['schema-version'] %>
# [Tool]           <%= descriptor['name'] %>
# [Version]        <%= descriptor['tool-version'] || '?' %>
# See the CbrainTask Programmer Guide (CBRAIN Wiki) for a more complete picture
# of how CbrainTasks are constructed.
% # NOTE: This template's weird indentation is there to try and make the
% # generated code as legible as possible.

# Portal-side CbrainTask subclass to launch <%= name %>
class CbrainTask::<%= name %> < <%= descriptor['cbrain:inherits-from-class'] || 'PortalTask' %>

  Revision_info=CbrainFileRevision[__FILE__] #:nodoc:

% # Maximum width of a given +key+'s value in a +list+ of hashes
% max_width = lambda do |list, key|
%   list.map { |i| i[key].to_s.length rescue 0 }.max
% end
%
% # Parameter types
% params       = descriptor['inputs'].dup
% outputs      = descriptor['output-files'].dup
% required     = params.select { |i| ! i['optional']     }
% optional     = params.select { |i| i['optional']       }
% defaults     = params.select { |i| i['default-value']  }
% files        = params.select { |i| i['type'] == 'File' }
% file_lists   = files.select  { |i| i['list']           }
%
% # Parameter groups
% groups    = descriptor['groups'].dup rescue []
% noGroups  = (groups.length == 0)
% gIdToMbrs = groups.inject({}){ |m,v| m.merge( v["id"] => v["members"] ) }
% gIdToPrms = gIdToMbrs.map { |k,v| [k, params.select{ |p| v.include? p["id"] }] }.to_h
%
% # Parameter Maps: ids => [ target_ids ] for disables/requires
% disables_map = params.inject({}){ |hmap,i| (res=i["disables-inputs"]) ? hmap.merge(i["id"]=>res) : hmap }  
% requires_map = params.inject({}){ |hmap,i| (res=i["requires-inputs"]) ? hmap.merge(i["id"]=>res) : hmap }

% # Special case; we only have one file input parameter and it only
% # allows single files.
% single_file = files.first if files.count == 1 && file_lists.empty?
% if single_file
%   # The parameter's validation is made in final_task_list and is no longer
%   # optional if it was.
%   params.delete(single_file)
%   required.delete(single_file)
%   optional.delete(single_file)
% end
%
  # Task properties are special boolean properties of your task, returned as a
  # hash table. Used internally by CBRAIN to enable/disable special task
  # handling. All properties are unset (false) by default.
  #
  # Both generated task classes (ClusterTask for the Bourreau, PortalTask for
  # the Portal) have different properties as they have different use cases.
  # The properties below are for the Portal-side class (PortalTask).
  def self.properties #:nodoc:
    super.merge({
      # The task's parameter view doesn't have a submit button, and one should
      # be added automatically. Note that the views automatically generated
      # along with this template *do* have a submit button.
      :no_submit_button => false,

      # Disable the use of presets (saved parameters). If enabled, the preset
      # panel is shown above the task's parameter view and allows users to
      # save a task's parameters and re-use them later to launch another similar
      # task.
      :no_presets => false,

      # Allow CBRAIN to parallelize multiple instances of this task/job on a
      # single cluster node; each job's generated shell script will be run
      # as a background job on the node at the same time and CBRAIN will wait
      # for all tasks to be done before moving to the data processing stage.
      :use_parallelizer => false,

      # Indicate that this task may alter its input files, and thus the task's
      # owner must have write access to the input files to be allowed to launch
      # the task. Most tasks do not alter their input files, but this is a safe
      # default.
      :readonly_input_files => <%=
        if descriptor.has_key?('cbrain:readonly-input-files')
          !!descriptor['cbrain:readonly-input-files']
        elsif descriptor.has_key?('cbrain:alters-input-files')
          !descriptor['cbrain:alters-input-files']
        else
          false
        end
      %>,
    })
  end

% unless defaults.empty?
  # Default values for some (all?) of <%= name %>'s parameters. Those values
  # reflect the defaults taken by the tool's developer; feel free to change
  # them to match your platform's requirements.
  def self.default_launch_args #:nodoc:
    {
%   id_width = max_width.(defaults, 'id') + "'".length
%   defaults.each do |default|
      <%=
        ":'%-#{id_width}s => %s," % [
          default['id'] + "'",
          default['default-value'].inspect
        ]
      %>
%   end
    }
  end

% end
  # Callback called just before the task's form is rendered. At this point,
  # the task's params hash contains at least the default list of input
  # userfiles under the key :interface_userfile_ids. 
  def before_form #:nodoc:
% file_types = descriptor['inputs']
%   .select { |i| ! i['optional'] && i['type'] == 'File' }
%   .map    { |i| i['cbrain-file-type'] }
%   .uniq
% unless file_types.empty?
    # Resolve interface_userfile_ids to actual userfile objects
    files = Userfile.find_all_by_id(self.params[:interface_userfile_ids])

%   if file_types.length == 1 && !file_types.first
    # At least one file is required.
    cb_error "Error: this task requires at least one input file" if files.empty?
%   else
    # Some input files are not optional and specific file types are
    # required. Make sure the given input files are adequate.

    # Ensure that +files+ contains at least one file of type +type+
    ensure_one = lambda do |files, type|
      type = type.constantize unless type.is_a?(Class)
      cb_error "Error: this task requires at least one file of type '#{type.name}'" unless
        files.any? { |f| f.is_a?(type) }
    end

%     file_types.compact.each do |type|
    ensure_one.(files, '<%= type %>')
%     end
%   end

% end
    ""
  end

  # Callback called just after the task's form has been submitted by the user.
  # At this point, all the task's params will be filled. This is where most
  # validations happens.
  def after_form #:nodoc:
% unless params.empty?
    params = self.params

%   unless file_lists.empty?
    # Assign the default input file list from interface_userfile_ids to unset
    # file list parameters.
    [
%     file_lists.each do |param|
      :'<%= param['id'] %>',
%     end
    ].each do |list|
      params[list] = params[:interface_userfile_ids].dup unless
        params[list].is_a?(Enumerable) # Allows explicitly empty lists
    end

%   end
    # Sanitize every input parameter according to their expected type

%   sanitize_param = format_call('sanitize_param', params) { |param| [
%     ":'#{param['id']}'",
%     ":#{param['type'].downcase}",
%     (param['cbrain-file-type'] ? ":file_type => '#{param['cbrain-file-type']}'" : nil)
%   ] }
%
%   unless required.empty?
    # Required parameters
%     required.each do |param|
    <%= sanitize_param.(param) %>
%     end

%   end
%   unless optional.empty?
    # Optional parameters
%     calls      = optional.map { |param| [ sanitize_param.(param), param ] }
%     call_width = calls.map { |c, p| c.length }.max
%     calls.each do |call, param|
    <%= "%-#{call_width}s unless params[:'%s'].nil?" % [ call, param['id'] ] %>
%     end

%   end
%#
%####
%#  Write the checks for requires-inputs and disables-inputs. 
%#  Indentation is to preserve pretty output
%#
%   # Helper for writing out a dictionary of keys to value arrays to a literal
%   writeLiteralMap = lambda do |name,inmap|
%     lenLongestKey = inmap.keys.map{ |x| x.to_s.length }.max + "''".length     
    <%= "%s = {" % name %>     
%     inmap.each do |key,valArr|
%       vals = valArr.map{ |s| ":'%s'" % s }.join(", ")
      <%= ":%-#{lenLongestKey}s => [%s]," % [ "'" + key + "'" , vals ] %> 
%     end
    <%= "}" %>
%   end  
%#  
%   # Helper for writing out the checker loops
%   # Can write a loop checking either disables (base="disable") or requires (base="require") violations
%   generateCheckerLoop = lambda do |base|
%     key, vals, req = base + 'r', base + 'ds', base == "require" 
    <%= base + "sMap.each do |"+key+", "+vals+"|" %>   
      unless isInactive.(<%= key %>)
        for <%= base+'d' %> in <%= vals %>
          msg = <%='\'is %s \' + %s.pretty_params_names[%s]' % [base + 'd ' + (req ? 'for' : 'by'), name, key] %> 
          params_errors.add(<%= base+'d' %>, msg) <%= req ? 'if' : 'unless' %> isInactive.(<%= base+'d' %>)
        end
      end
    end
%#
%   end
%#
%# Output to template 
% unless requires_map.empty? and disables_map.empty?
    # Helper function for detecting inactive parameters (or false for flag-type parameters)
    # Note that empty strings are allowed and no parameter types except flags pass booleans
    isInactive = lambda { |x| params[x].nil? || (params[x]==false) }
%   comment = "# A Map: id -> [ids] where ids are the parameters %s by the input id"

    <%= (comment % "required") unless requires_map.empty? %>
%   writeLiteralMap.("requiresMap",requires_map) unless requires_map.empty?

    <%= (comment % "disabled") unless disables_map.empty? %>
%   writeLiteralMap.("disablesMap",disables_map) unless disables_map.empty?

% end
%#
% unless requires_map.empty?
    # Check that requires-inputs is not violated
    # If the parameter is filled in, the ones it requires must be too
%    generateCheckerLoop.("require")
% end    

% unless disables_map.empty?
    # Check that disables-inputs is not violated
    # If the parameter is active, the ones it disables must not be
%    generateCheckerLoop.("disable")
% end
%#
%####
%# Check for violations pertaining to parameter groups
%# In particular, check that mutual exclusivity and one-is-required are satisfied 
%#
% unless noGroups
%# Check if any groups require checking
% getGroupsWith = lambda { |prop| groups.select{ |g| g[prop] }.map{ |g| ":'"+g["id"]+"'" }.join(", ") }
% mutexGrps     = getGroupsWith.("mutually-exclusive") 
% oneReqGrps    = getGroupsWith.("one-is-required")
% hasMutex      = (mutexGrps != "")
% hasOneReq     = (oneReqGrps != "")
%#
% if (hasMutex || hasOneReq)
   
    # Groups with the mutually exclusive or one-is-required
    <%= 'mutexGroups = [%s]'  % mutexGrps  if hasMutex %>
    <%= 'oneReqGroups = [%s]' % oneReqGrps if hasOneReq %>
    # Mapping from groupId to members list
%   writeLiteralMap.("gidToMbrs", gIdToMbrs)
    # Mapping from groupId to group name
    grpName = {<%= groups.map{ |g| ":'" + g["id"] + "\' => \'" + g["name"] + "'" }.join(", ") %>}
% end
% if hasMutex
    # Lambda for checking mutual exclusivity
    isMutex = lambda { |gid| gidToMbrs[gid].select{ |m| ! isInactive.(m.to_sym) }.count <= 1 }
    mutexGroups.each do |group| # Check for violations of group mutex properties
      errMsg = "violates group mutual exclusivity requirement"
      params_errors.add(grpName[group], errMsg) unless isMutex.(group)
    end
% end
% if hasOneReq
    # Lambda for checking one-is-required (at least one is active)
    hasOneActive = lambda { |gid| gidToMbrs[gid].select{ |m| ! isInactive.(m.to_sym) }.count > 0 }
    oneReqGroups.each do |group| # Check for violations of group one-is-required properties
      errMsg = "violates group one-is-required specification"
      params_errors.add(grpName[group], errMsg) unless hasOneActive.(group)
    end
% end
%#
% end # No groups check
%#  
%# End parameter group properties check

% end # End unless params.empty?
    ""
  end

  # Add pretty parameter names for the error messages to use
  # Associates the id symbol with the name field
  def self.pretty_params_names
    {
%     id_width = max_width.(params,"id") + "''".length  
%     for param in params
      <%= ":%-#{id_width}s => '%s'," % ["'" + param["id"] + "'", param["name"]]  %>
%     end     
    }
  end

  # Final set of tasks to be launched based on this task's parameters. Only
  # useful if the parameters set for this task represent a set of tasks
  # instead of just one.
  def final_task_list #:nodoc:
% if single_file
    # Create a list of tasks out of the default input file list
    # (interface_userfile_ids), each file going into parameter '<%= single_file['id'] %>'
    self.params[:interface_userfile_ids].map do |id|
      task = self.dup

      # Set and sanitize the one file parameter for each id
      task.params[:'<%= single_file['id']%>'] = id
%   if single_file['cbrain-file-type']
      task.sanitize_param(:'<%= single_file['id'] %>', :file, :file_type => '<%= single_file['cbrain-file-type']%>')
%   else
      task.sanitize_param(:'<%= single_file['id'] %>', :file)
%   end

      task.description ||= ''
      task.description  += " <%= single_file['id']%>: #{Userfile.find(id).name}"
      task.description.strip!
      task
    end
% else
    [ self ]
% end
  end

  # Task parameters to leave untouched by the edit task mechanism. Usually
  # for parameters added in after_form or final_task_list, as those wouldn't
  # be present on the form and thus lost when the task is edited.
  def untouchable_params_attributes #:nodoc:
% if outputs.empty?
    { }
% else
    # Output parameters will be present after the task has run and need to be
    # preserved.
    {
%   id_width = max_width.(outputs, 'id') + "'".length
%   outputs.each do |output|
      <%= ":'%-#{id_width}s => true," % (output['id'] + "'") %>
%   end
    }
% end
  end

  # Generic helper methods

  # Ensure that the parameter +name+ is not null and matches a generic tool
  # parameter +type+ (:file, :numeric, :string or :flag) before converting the
  # parameter's value to the corresponding Ruby type (if appropriate).
  # For example, sanitize_param(:deviation, :numeric) would validate that
  # self.params[:deviation] is a number and then convert it to a Ruby Float or
  # Integer.
  #
  # Available +options+:
  # [file_type] Userfile type to validate a parameter of +type+ :file against.
  #
  # If the parameter's value is an array, every value in the array is checked
  # and expected to match +type+.
  #
  # Raises an exception for task parameter +name+ if the parameter's value
  # is not adequate.
  def sanitize_param(name, type, options = {})
    # Taken userfile names. An error will be raised if two input files have the
    # same name.
    @taken_files ||= Set.new

    # Fetch the parameter and convert to an Enumerable if required
    values = self.params[name] rescue nil
    values = [values] unless values.is_a?(Enumerable)

    # Validate and convert each value
    values.map! do |value|
      case type
      # Try to convert to integer and then float. Cant? then its not a number.
      when :number
        if (number = Integer(value) rescue Float(value) rescue nil)
          value = number
        elsif value.blank?
          params_errors.add(name, ": value missing")
        else
          params_errors.add(name, ": not a number (#{value})")
        end

      # Nothing special required for strings, bar for symbols being acceptable strings.
      when :string
        value = value.to_s if value.is_a?(Symbol)
        params_errors.add(name, " not a string (#{value})") unless value.is_a?(String)

      # Try to match against various common representation of true and false
      when :flag
        if value.is_a?(String)
          value = true  if value =~ /^(true|t|yes|y|on|1)$/i
          value = false if value =~ /^(false|f|no|n|off|0|)$/i
        end

        if ! [ true, false ].include?(value)
          params_errors.add(name, ": not true or false (#{value})")
        end

      # Make sure the file ID is valid, accessible, not already used and
      # of the correct type.
      when :file
        unless (id = Integer(value) rescue nil)
          params_errors.add(name, ": invalid or missing userfile (ID #{value})")
          next value
        end

        unless (file = Userfile.find_accessible_by_user(value, self.user))
          params_errors.add(name, ": cannot find userfile (ID #{value})")
          next value
        end

        if @taken_files.include?(file.name)
          params_errors.add(name, ": file name already in use (#{file.name})")
        else
          @taken_files.add(file.name)
        end

        if type = options[:file_type]
          type = type.constantize unless type.is_a?(Class)
          params_errors.add(name, ": incorrect userfile type (#{file.name})") if
            type && ! file.is_a?(type)
        end
      end

      value
    end

    # Store the value back
    self.params[name] = values.first unless self.params[name].is_a?(Enumerable)
  end

end
