
<%%-
#
# CBRAIN Project
#
# Copyright (C) 2008-2012
# The Royal Institution for the Advancement of Learning
# McGill University
#
# This program is free software: you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation, either version 3 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program.  If not, see <http://www.gnu.org/licenses/>.
#
-%>

<%% content_for :head do %>
  <link href="/stylesheets/boutiques.css" media="all" rel="stylesheet" type="text/css" />
<%% end %>

<%%-
# NOTE: This is a working template generated from a descriptor:
# [Schema]         <%= schema['id'] %>
# [Schema version] <%= descriptor['schema-version'] %>
# [Tool]           <%= descriptor['name'] %>
# [Version]        <%= descriptor['tool-version'] || '?' %>
# See the CbrainTask Programmer Guide (CBRAIN Wiki) for a more complete picture
# of how CbrainTasks are constructed.
-%>
<%-
# NOTE: This template's weird indentation is there to try and make the
# generated code as legible as possible.
-%>

<%-
  # Parameter types
  params   = descriptor['inputs'].dup
  required = params.select { |i| ! i['optional'] }
  optional = params.select { |i|   i['optional'] }
  defaults = params.select { |i|   i['default-value']  }

  # Parameter groups and maps
  groups    = descriptor['groups'].dup rescue []
  noGroups  = (groups.length == 0)
  gIdToMbrs = groups.inject({}){ |m,v| m.merge( v["id"] => v["members"] ) }
  gIdToPrms = gIdToMbrs.map { |k,v| [k, params.select{ |p| v.include? p["id"] }] }.to_h

  # Single input file case
  files       = params.select { |i| i['type'] == 'File' }
  single_file = files.first if files.count == 1 && ! files.any? { |f| f['list'] }
-%>
<%% input_files = Userfile.find_all_by_id(params[:interface_userfile_ids]) rescue [] %>

<%%
    # Handling for multi-task generation via CBCSVs
    cbcsvs       = input_files.select { |f| f.is_a?( CbrainFileList ) }
    cbcsvToFiles = cbcsvs.inject({}) do |m,f|              # Only used for preview button
      m.merge(f.name => f.ordered_raw_ids.map{ |r| (r==0 || r.nil?) ? ' ' : # Space can't be a filename in cbrain
        (Userfile.find_all_accessible_by_user(current_user).where('userfiles.id' => r).first rescue nil) }
      )
    end
    single_file = <%= single_file ? "\"#{single_file['id']}\"" : "nil" %>
%%>

<%-
  # Lambda for checking group membership
  whichGroup = lambda { |s| gIdToMbrs.select{ |v| gIdToMbrs[v].include? s }.first[0] rescue nil }
-%>

<%%#
  Generate a parameter label for HTML input with id +id+.
  +name+ corresponds to the tool parameter name to display,
  +optional+ indicates that the parameter is optional (or not) and
  +flag+ is the parameter's command-line flag if available.
%%>
<%% label = lambda do |id, name, optional: false, flag: nil| %>
  <label class="tsk-prm-lbl" for="<%%= id.to_la_id %>">
    <%%= name %>
    <%% if flag.present? %>
      (<code class="cmd-flag"><%%= flag %></code>)
    <%% end %>
    <%% unless optional %>
      <span class="required">*</span>
    <%% end %>
  </label>
<%% end %>

<%%#
  Generate a generic parameter input field with HTML id +id+ and name +name+.
  +type+ is the kind of input field to generate (text or hidden),
  +value+ is the input field's initial value,
  +optional+ indicates that the parameter is optional (and the name should not
  directly be placed on the tag) and
  +placeholder+ is the placeholder text to fill the input with while awaiting
  user input
%%>
<%% input = lambda do |id, name, type: 'text', value: nil, optional: false, placeholder: nil| %>
  <%% value = @task.params[name.to_sym] if name && value.nil? %>
  <input <%% if id %>
          id="<%%= id.to_la_id %>"
         <%% end %>
         class="tsk-prm-in"
         type="<%%= type %>"
         <%% if name %>
           <%%= optional ? 'data-name' : 'name' %>="<%%= name.to_la %>"
         <%% end %>
         <%% if value %>
           value="<%%= value %>"
         <%% end %>
         <%% if placeholder %>
           placeholder="<%%= placeholder %>"
         <%% end %>
  />
<%% end %>

<%%#
  Generate a list of inputs suitable for a list parameter with HTML id +id+
  and name +name+. +values+, +optional+ and +placeholder+ work similarly to
  input's corresponding arguments.
%%>
<%% input_list = lambda do |id, name, values: nil, optional: false, placeholder: nil| %>
  <%%
    values = @task.params[name.to_sym] if name && values.nil?
    values = values.is_a?(Enumerable) ? values.compact : [values].compact
    first = values.pop
  %>
  <ul class="tsk-prm-list">
    <li>
      <%%
        input.(id, name + "[]",
          value:       first,
          optional:    optional,
          placeholder: placeholder
        )
      %>
      <span class="tsk-prm-add ui-icon ui-icon-plus"></span>
    </li>
    <%% values.each do |value| %>
      <li>
        <%%
          input.(nil, name,
            value:       value,
            optional:    optional,
            placeholder: placeholder
          )
        %>
        <span class="tsk-prm-add ui-icon ui-icon-minus"></span>
      </li>
    <%% end %>
  </ul>
<%% end %>

<%%#
  Generate a fancy checkbox for flag or optional parameters with HTML +id+.
  If +name+ is given, a checkbox suitable for flag parameters is generated
  while one for optional arguments is generated otherwhise. The checkbox's
  initial state (checked or not) is +check+.
%%>
<%% checkbox = lambda do |id, name: nil, check: nil| %>
  <%%#
    FIXME for some obscure reason, naming the 'check' parameter 'checked'
    makes the first parameter (id) become nil regardless of the value passed
    in. This only seems to occur in the context of Rails' template renderer.
  %>
  <%%
    id    = name ? id.to_la_id : "tsk-prm-opt-#{id}"
    type  = name ? 'chk' : 'opt'
  %>
  <%% if name %>
    <%% check = @task.params[name.to_sym] if check.nil? %>
    <%%#
      As a checkbox's value is not sent if left unchecked, a hidden 'back' field
      sends the unchecked state is used to send. Rails overwrites this 'back'
      value with the checbox's when the checkbox is checked, as the checkbox is
      after the 'back' field.
    %>
    <input class="tsk-prm-chk-in"
           type="hidden"
           name="<%%= name.to_la %>"
           value="0"
    />
    <input class="tsk-prm-chk"
           type="checkbox"
           id="<%%= id %>"
           name="<%%= name.to_la %>"
           value="1"
           <%% if check %>
             checked="checked"
           <%% end %>
    />
  <%% else %>
    <input class="tsk-prm-opt"
           type="checkbox"
           id="<%%= id %>"
           <%% if check %>
             checked="checked"
           <%% end %>
    />
  <%% end %>
  <label class="tsk-prm-<%%= type %>-lbl" for="<%%= id %>">
    <span class="tsk-prm-<%%= type %>-icon ui-icon ui-icon-check"></span>
  </label>
<%% end %>

<%%#
  Generate a drop-down list for a set of +options+ (value, label pairs) with
  HTML id +id+ and name +name+.
  +nothing+ corresponds to the text displayed if +options+ is empty and
  +optional+ indicates if the parameter is optional (or not)
%%>
<%% dropdown = lambda do |id, name, options = [], nothing: '(Nothing to select)', optional: false, default: nil| %>
  <%% value = @task.params[name.to_sym] if name %>
  <%%
    input.(id, name,
      type:     'hidden',
      value:    value,
      optional: optional
    )
  %>
  <div class="tsk-prm-sel">
    <%% if options.empty? %>
      <span class="tsk-prm-sel-lbl disabled">
        <%%= nothing %>
      </span>
    <%% else %>
      <span class="tsk-prm-sel-icon ui-icon ui-icon-triangle-1-s"></span>
      <span class="tsk-prm-sel-lbl">
        <%% if (pair = options.select { |o| o.first == value }.first) %>
          <%%= pair.last %>
        <%% end %>
      </span>
      <ul class="tsk-prm-sel-opt">
        <%% options.each do |value, label| %>
         <%% if default.nil? %>
          <li data-value="<%%= value %>"><%%= label %></li>
         <%% else %>
          <%% dval = (default==value) ? " data-selected=\"true\"" : "" %>
          <li data-value="<%%= value %>"<%%= dval %>><%%= label %></li>
         <%% end %>
        <%% end %>
      </ul>
    <%% end %>
  </div>
<%% end %>

<%%# Generate a checkbox for a parameter grouping %>
<%% groupCheckbox = lambda do |id, defaultChecked = false| %>
  <input class='group-toggler'
    type='checkbox'
    id='<%%= id %>_chk'
    <%%= 'checked=\'checked\'' if defaultChecked %>
  />
  <label for="<%%= id %>_chk"></label>
<%% end %>

<%%# Generate a parameter's description block for +desc+ %>
<%% description = lambda do |desc, isGroupMember = false| %>
  <span class="tsk-prm-desc">
    <%%= desc %><%%= "<br><br>".html_safe if isGroupMember %>
  </span>
<%% end %>

<%%# Give a short (up to +max+ characters) representation of +list+ %>
<%%
  short_repr = lambda do |list, max|
    str = list.map(&:to_s).join(', ')
    str.length <= max ? str : (str[0, max - 3] + '...')
  end
%%>

<%# Generate a complete HTML block for a given parameter +param+ -%>
<%- parameter = lambda do |param, isGroupMember = false| -%>
  <%-
    id    = param['id']
    type  = param['type'].downcase.to_sym
    opt   = !!(param['optional'] && type != :flag)
    list  = param['list']
  -%>
  <%-
    classes  = [ 'tsk-prm', type.to_s ]
    classes << 'list' if list
    classes << 'prm-grp-mbr' if isGroupMember
  -%>
    <%% id = '<%= id %>' %>
    <li class="<%%= id %> <%= classes.join(' ') %>">
      <%%
  <%- if type == :flag -%>
        # Flag input toggle
        checkbox.(id, name: id)

  <%- end -%>
        # Name/Label
        label.(id, %q{ <%= param['name'] %> },
  <%- if param['command-line-flag'] -%>
          optional: <%= param['optional'] %>,
          flag:     '<%= param['command-line-flag'] %>'
  <%- else -%>
          optional: <%= param['optional'] %>
  <%- end -%>
        )

  <%- if opt -%>
        # Optional parameter enable/disable toggle
        checkbox.(id)

  <%- end -%>
  <%- if type == :file -%>
    <%- if single_file -%>
        # Automatic single file input
        dropdown.(id, id,
          [], nothing: short_repr.(input_files.map(&:name), 65),
          optional: <%= opt %>
        )
    <%- elsif param['cbrain-file-type'] -%>
        # File input dropdown
        type = '<%= param['cbrain-file-type'] %>'.constantize rescue nil
        dropdown.(id, id,
          input_files
            .select { |f| f.is_a?(type) if type }
            .map    { |f| [ f.id.to_s, f.name ] },
          optional: <%= opt %>
        )
    <%- else -%>
        # File input dropdown
        dropdown.(id, id,
          input_files.map { |f| [ f.id.to_s, f.name ] },
          optional: <%= opt %>
        )
    <%- end -%>

  <%- elsif [ :string, :number ].include?(type) -%>
    <%-
      arg_width = [
        'optional',
        ('placeholder' if type == :number),
      ].compact.map(&:length).max + ':'.length
    -%>
    <%- if list -%>
        # Input field list
        input_list.(id, id,
    <%- else -%>
        # Input field
        input.(id, id,
    <%- end -%>
    <%- if type == :number -%>
          optional:    <%= opt.to_s %>,
          placeholder: '0.0'
    <%- else -%>
          optional: <%= opt.to_s %>
    <%- end -%>
        )
  <%- elsif type == :enum -%>
    <% enumVals = param["enum-value-choices"] %>
        # Enum value dropdown
        dropdown.(id, id,
          <%= enumVals.map { |v| [v, v] } %>,
          optional: <%= opt %>,
          default:  <%= "\"#{defaults.find { |d| d['id']==id }['default-value']}\"" rescue "nil" %>
        )
  <%- end -%>
  <%- if param['description'] -%>
        # Description
        description.(<<-'DESC',<%= isGroupMember %>)
          <%= param['description'] %>
        DESC
  <%- elsif not param['description'] and isGroupMember %>
        # Blank Line for empty description (fixes spacing)
        description.('',<%= isGroupMember %>)
  <%- end -%>
     %>
    </li>
<%- end -%>
<%# Generate HTML for a group -%>
<%- writeGroup = lambda do |group| -%>
  <%-
    # Get group parameters
    id = group['id']
    name = group['name']
    groupDescription = group['description']
    groupParams = gIdToPrms[id]
    mbrs = gIdToMbrs[id]
    defaultChecked = group['one-is-required'] || required.any? { |p| mbrs.include? p["id"] }
  -%>
  <div class="group <%= id %>">
    <%# Write group header %>
    <div style="border-bottom: 2px solid #bbbbbb; padding-bottom: 2px;">
      <h3 style="border-width: 0px; margin: 0px; padding: 1px; padding-left: 0px;">
        <%= name %> <%% groupCheckbox.('<%= id %>',<%= defaultChecked %>) %>
      </h3>
      <h5 style="font-size : 9.5pt; font-weight: normal; padding-top: 2px;" class="grp-desc">
        <%= groupDescription %>
      </h5>
    </div><%%= "<br>".html_safe %>
    <%# Write group parameters (required ones first) %>
    <%- groupParams.each { |p| parameter.(p, true) if required.any? { |r| p["id"]==r["id"] } } -%>
    <%- groupParams.each { |p| parameter.(p, true) if optional.any? { |t| p["id"]==t["id"] } } -%>
  </div>

<%- end -%>
<div class="task-params">
  <%- if params.empty? -%>
  <%= name %> has no parameters.
  <%- else -%>
  <ul>
%   # Write info for ungrouped parameters
    <%- for param in required do parameter.(param) if whichGroup.(param["id"]).nil? end -%>
    <%- for param in optional do parameter.(param) if whichGroup.(param["id"]).nil? end -%>
%   # Write info for grouped parameters
    <%- groups.each(&writeGroup) unless noGroups  -%>
  </ul>
  <%- end -%>
</div>

<div class="preview-div">
  <p>
      <input class="ui-button ui-widget ui-state-default ui-corner-all" id="previewer"
              type="button" value="Preview" style="float:right">
  </p>
</div>

<script type="application/javascript">
$(function () {
  "use strict";

  var parameters = $('.tsk-prm');

  /*
   * Remove the checked attribute of checkboxes and use their internal
   * state instead.
   */
  parameters.find("input[type='checkbox'][checked='checked']").each(function () {
    $(this)
      .removeAttr('checked')
      .prop('checked', true);
  });

  /*** Handle disables and requires relations between parameters ***/

% #
% # Make maps for which parameters disable/require each other
% #
% # Generates a map from id to [ids affected by the key id] for a given action name
% makeActorActionMap = lambda do |action|
%   params.inject({}){ |hmap,i| (res=i[action]) ? hmap.merge(i["id"]=>res) : hmap }
% end
% #
% # Generates a map from id to [ids affecting the key id] for a given action name
% makeReceiverActionMap = lambda do |action|
%   doesMap = makeActorActionMap.(action)
%   doneMap = doesMap.inject({}) do |map,(key,val)| # invert the relation above (active->passive)
%     for v in val do
%       if map[v].nil? then map[v] = [key] else map[v] << key end
%     end
%     map
%   end
% end
% #
% # The actual maps: idIn -> [ids disabled/required by idIn]
% disabledBy_map = makeReceiverActionMap.("disables-inputs")
% requires_map   = makeActorActionMap.("requires-inputs")
% #
% # Implement dynamic mutual exclusion within a group by pairwise adding to the disables map
% for group in groups
%   if group['mutually-exclusive']
%     for mId in group['members']
%       # Add all members of the group, except this one and ones already disabling it
%       alreadyDisables = lambda { |id| (disabledBy_map[mId] || []).include? id }
%       toAdd = group['members'].select{ |id| (id!=mId) && (! alreadyDisables.(id) ) }
%       disabledBy_map[mId] = ( (disabledBy_map[mId] + toAdd) rescue toAdd )
%     end
%   end
% end
% #
  /* Javascript dictionaries for names, disabledBy, and requires */
% # Helper for producing a javascript version of the ruby map
% jsMapOf = lambda do |hmap, numbers: false|
%   n = hmap.size
%   hmap.each_with_index do |(k,v),i|
%    if v.is_a? Array
      <%= "\"#{k}\" : [" + v.map{ |s| "\"#{s}\"" }.join(',') + "]" + ((i == n-1) ? '' : ',') %>
%    elsif numbers # Don't quote numbers
      <%= "\"#{k}\" : " + v.to_s + ((i == n-1) ? '' : ',') %>
%    else
      <%= "\"#{k}\" : \"" + v + "\"" + ((i == n-1) ? '' : ',') %>
%    end
%   end
% end
% #
  var namesMap = {
%   jsMapOf.( params.inject({}){ |hmap,x| hmap.merge( x["id"] => x["name"].gsub(/\"/,"\\\"") ) } )
  }
  var requiresMap = {
%   jsMapOf.(requires_map)
  };
  var disabledByMap = {
%   jsMapOf.(disabledBy_map)
  };

%# Generate JS functions for handling disables/requires
%#
  // Function to map ids to names to make the messages a little prettier
  var idToName = function(x){ return namesMap[x]; }

  // Helper function that checks whether a given parameter is active
  var isActiveParam = function(id) {
    var targ = $( 'li.' + id + '.tsk-prm' );
    if( targ.hasClass( 'flag' ) ){ // Flag case
      return targ.find('.tsk-prm-chk').prop('checked');
    }
    return targ.find('.tsk-prm-opt').prop('checked'); // Non-flag case
  }

  // Helper for checking array containment because JS won't let you use 'in' for arrays in a useful way
  var arrHas = function(arr,val){
    return ($.inArray(val,arr) > -1)
  }

  // Warning message style written to tell the user when/why something is disabled or wrong
  var warningStyle = 'style="display: block; float: right; font-style: normal; font-weight: normal; ' +
                     'font-size: 0.95em; color: rgb(255,50,50); margin-right: 17pt"';

  /*
   * Disables the targets of every active parameter within its disables list
   * Also disables parameters whose required parameters are inactive, unless it
   * is a mutual required relation.
   */
  function handleDisablesAndRequires() {

    // Function for disabling/enabling parameters
    var toggleFunctionality = function(target, shouldDisable, greyOutMsg){
      var lightGrey   = '#d3d3d3'; // Firefox does not grey out disabled html elements
      // Selector classes
      var toGreyOut   = '.tsk-prm-in, .tsk-prm-opt-lbl, .tsk-prm-chk-lbl, .tsk-prm-sel';
      var toDisable   = '.tsk-prm-in, .tsk-prm-opt, .tsk-prm-chk';
      var iconClasses = '.tsk-prm-opt-icon.ui-icon-check, .tsk-prm-sel-icon, .tsk-prm-add.ui-icon';
      // Disable and grey out text, file, & flag inputs, as well as their checkboxes
      target.find( toGreyOut ).css('background-color', shouldDisable ? lightGrey : '');
      target.find( toDisable ).attr('disabled', shouldDisable);
      // For lists and files, toggle the ability to add more entries or change selections
      target.find('.tsk-prm-add.ui-icon,.tsk-prm-sel').css("pointer-events",shouldDisable?"none":"auto");
      // Erase the warning message: if one is needed it will be rewritten below
      target.find('.tsk-prm-lbl').find('label.disable-msg').remove();
      // Handle properties treated differently in each toggle case
      if( shouldDisable ){
        target.find( iconClasses ).addClass('ui-state-disabled'); // disable icons
        target.find('.tsk-prm-opt, .tsk-prm-chk').prop('checked', false); // uncheck checkboxes
        target.find('.tsk-prm-in').val(''); // wipe textbox input areas
        target.find('ul.tsk-prm-list').find('li').has('.ui-icon-minus').remove(); // rm list subitems
        // Write warning message
        var msg   = '<label class="disable-msg" ' + warningStyle + '>' + greyOutMsg  + '</label>';
        target.find('.tsk-prm-lbl').append( msg );
      }
      else {
        target.find( iconClasses ).removeClass('ui-state-disabled') // put icons in enabled state
      }
    }

    // Get combined keyset of potentially affected parameters
    var affectedIds = $.unique(Object.keys(disabledByMap).concat(Object.keys(requiresMap)));
    // Run twice because the order matters: a param can be wrongly disabled if it is processed before its
    // disabler is deactivated
    affectedIds = affectedIds.concat( affectedIds.slice() )

    // Iterate over parameters, enabling and disabling as needed
    affectedIds.forEach( function( key ) {

      // Handle targeted disabling
      var disablers = [];
      if( key in disabledByMap ){
        var vals = disabledByMap[key], len = vals.length;
        // Look for disabling parameters
        for(var i = 0; i < len; ++i){
          if( isActiveParam(vals[i]) ){
            disablers.push(vals[i]);
          }
        }
      }

      // Handle parameter requirements (excludes parameters with mutual requirement)
      var missingReqs = [];
      if( key in requiresMap ){
        var vals = requiresMap[key], n = vals.length;
        for(var i = 0; i < n; ++i){
          // If the required parameter is not checked (active)
          if( ! isActiveParam(vals[i]) ){
            // If the required parameter does not require the current target parameter
            if( ( ! (vals[i] in requiresMap) ) || requiresMap[vals[i]].indexOf(key) == -1 ){
              missingReqs.push( vals[i] ); // Then add it to our set of missing requirements
            }
          }
        }
      }

      /* Perform disablings/enablings */
      // Disable the parameter is any of its disablers are on
      var target = $( 'li.' + key + '.tsk-prm' );
      if(disablers.length != 0){
        toggleFunctionality(target, true, "Disabled by " + disablers.map(idToName).join(", "));
      }
      // Disable the parameter if it is missing any of its requirements
      else if(missingReqs.length != 0){
        toggleFunctionality(target, true, "Requires " + missingReqs.map(idToName).join(", "));
      }
      // Otherwise, enable the parameter
      else {
        toggleFunctionality(target, false, "");
      }

    });

  }

  /*** Handle constraints on numerical parameters ***/
% #
% # Make lists of which parameters are affected by which constraints
% mins = params.select { |p| p['type'] == 'Number' && p['minimum'] }
% maxs = params.select { |p| p['type'] == 'Number' && p['maximum'] }
% ints = params.select { |p| p['type'] == 'Number' && p['integer'] }
  /* Maps and lists of constrained parameters */
  var mins = {
%   jsMapOf.( mins.inject({}){ |hmap,x| hmap.merge( x["id"] => x["minimum"] ) }, numbers: true )
  };
  var maxs = {
%   jsMapOf.( maxs.inject({}){ |hmap,x| hmap.merge( x["id"] => x["maximum"] ) }, numbers: true )
  };

  var ints     = [<%= ints.map{ |v| "\"#{v['id']}\"" }.join(",") %>];
  var exclMins = [<%= mins.select{ |p| p['exclusive-minimum'] }.map{ |v| "\"#{v['id']}\"" }.join(",") %>];
  var exclMaxs = [<%= maxs.select{ |p| p['exclusive-maximum'] }.map{ |v| "\"#{v['id']}\"" }.join(",") %>];

  /* Adds warnings to number parameters that violate number constraints */
  function handleNumberConstraints() {

    // Warning message properties
    var cssType = 'num-warning-msg';

    // Helper for adding or removing warnings
    var toggleNumberConstraintWarning = function(target, shouldAdd, msg){
      // Remove the (old) warning message
      target.find('.tsk-prm-lbl').find('label.' + cssType).remove();
      // Add a warning message
      if( shouldAdd ) {
        var formattedMsg = '<label class="'+ cssType + '" ' + warningStyle + '>' + msg  + '</label>';
        target.find('.tsk-prm-lbl').append( formattedMsg );
      }
    }

    // Helper for checking whether strings are integers
    var isInt = function( n ){ return /^[-]?[0-9]+$/.test(n+''); }

    // Get combined keyset of potentially affected parameters
    var targs = $.unique(Object.keys(mins).concat(Object.keys(maxs).concat( ints )));

    // Handle min and max violations
    targs.forEach( function( key ) {

      // Read in the current target value(s)
      var target   = $( 'li.' + key + '.tsk-prm' );
      var subtargs = target.find('.tsk-prm-in').map( function(){ return $(this).val(); } );
      var targNum  = subtargs.length;

      // Remove warnings and leave for inactive parameters
      if( ! isActiveParam( key ) ){
        toggleNumberConstraintWarning( target, false, "" );
        return;
      }

      // Loop over possible targets (allows this approach to work for checking lists)
      for( var i = 0; i < targNum; ++i ) {
        // Get current value
        var currval = parseFloat( subtargs[i] );
        // Handle min violations
        if( arrHas(exclMins,key) && currval <= mins[ key ] ){
          toggleNumberConstraintWarning( target, true, "Warning! Exclusive min parameter value is " + mins[ key ] );
        }
        else if( key in mins && currval < mins[ key ] ){
          toggleNumberConstraintWarning( target, true, "Warning! Min parameter value is " + mins[ key ] );
        }
        // Handle max violations
        else if( arrHas(exclMaxs,key) && currval >= maxs[ key ] ){
          toggleNumberConstraintWarning( target, true, "Warning! Exclusive max parameter value is " + maxs[ key ] );
        }
        else if( key in maxs && currval > maxs[ key ] ){
          toggleNumberConstraintWarning( target, true, "Warning! Max parameter value is " + maxs[ key ] );
        }
        // Handle integer violations
        else if( arrHas(ints,key) && ! isInt( subtargs[i] ) ){
          toggleNumberConstraintWarning( target, true, "Warning! Parameter value must be an integer" );
        }
        // If no errors occurred, destroy any prior existing errors
        else{
          toggleNumberConstraintWarning( target, false, "" );
        }
        // Leave if an error is present (avoid list error suppression)
        if( target.find( 'label.' + cssType ).length > 0 ){ return; }
      }

    });

  }

  /* Permit real-time updates to the number warnings */
  parameters.delegate('.tsk-prm-in', 'keyup', function() {
    handleNumberConstraints();
  })


  /*** Optional parameters ***/

  /* Clicking on the parameter's checkbox toggles the parameter's state */
  parameters.delegate('.tsk-prm-opt, .tsk-prm-chk', 'change activate.tsk-prm', function () {
    var opt   = $(this),
        param = opt.parent();

    /*
     * When an optional parameter is enabled, add its name attribute
     * (stored in a data-* field) to send them with the POST.
     */
    if (opt.prop('checked')) {
      param.find('.tsk-prm-in').each(function () {
        var name = $(this).data('name');

        $(this).attr('name', name);
      });

    /*
     * When an optional parameter is disabled, clear its value(s) and name
     * attribute.
     */
    } else {
      /* Main value and name attribute */
      param
        .find('.tsk-prm-in')
        .removeAttr('name')
        .val('');

      /* Display value for drop-down inputs */
      param
        .find('.tsk-prm-sel-lbl')
        .text('');

      /* Remove all extra inputs in input lists */
      param
        .find('.tsk-prm-list > li')
        .slice(1)
        .remove();
    }

    /* Check for disables/requires updates */
    handleDisablesAndRequires();

    /* Add warnings for violations of number constraints */
    handleNumberConstraints();

  });

  /* Changing a parameter's value automatically marks it as active */
  parameters.delegate('.tsk-prm-in', 'focus activate.tsk-prm', function () {
    $(this)
      .closest('.tsk-prm')
      .find('.tsk-prm-opt')
      .prop('checked', true)
      .trigger('activate.tsk-prm');
  });

  /* Activate optional parameters with default values */
  parameters.find(".tsk-prm-in[value]").trigger('activate.tsk-prm');

  /* Drop-down lists */

  /*
   * Clicking anywhere but the drop-down closes it without changing the
   * selection.
   */
  $('.task-params').click(function () {
    $(this)
      .find('.tsk-prm-sel-opt')
      .hide();
  });

  /* Clicking on the drop-down's label or icon toggles its visibility */
  parameters.delegate('.tsk-prm-sel', 'click', function (event) {
    event.stopPropagation();

    $(this)
      .children('.tsk-prm-sel-opt')
      .toggle();
  });

  /* Clicking on a drop-down item selects it */
  parameters.delegate('.tsk-prm-sel-opt > li', 'click', function () {
    var item  = $(this),
        param = item.closest('.tsk-prm');

    /* Set the backing input element's value */
    param
      .find('.tsk-prm-in')
      .val(item.data('value'))
      .trigger('activate.tsk-prm');

    /* Display the newly selected value in the drop-down's label */
    param
      .find('.tsk-prm-sel-lbl')
      .text(item.text());
  });

  /* Add/remove buttons for list parameters */

  /* Clicking on a '+' button adds a new value row and enables the parameter */
  parameters.delegate('.tsk-prm-add.ui-icon-plus', 'click', function () {
    var name = $(this)
      .siblings('.tsk-prm-in')
      .attr('name');

    $(this)
      .closest('ul')
      .append(
        '<li>' +
          '<input ' +
            'class="tsk-prm-in" ' +
            'type="text" ' +
            'name="' + name + '" ' +
            'data-name="' + name + '" ' +
          '/> ' +
          '<span class="tsk-prm-rm ui-icon ui-icon-minus"></span>' +
        '</li>'
      )
      .siblings('.tsk-prm-opt')
      .prop('checked', true)
      .trigger('activate.tsk-prm');
  });

  /* Clicking on a '-' button removes the row from an input parameter list */
  parameters.delegate('.tsk-prm-rm, .ui-icon-minus', 'click', function () {
    $(this)
      .closest('li')
      .remove();
  });

  /* Toggling groups */
  (function (fcn) {
    $('.group-toggler').each(fcn).change(fcn);
  })(function () {
    $(this)
      .parent() // header (3)
      .parent() // inner div
      .siblings('.prm-grp-mbr, .grp-desc')
      .toggle( $(this).prop('checked') );
  });

  /* Preview Button */
  $("#previewer").click(function () {
    // Classes for the modal (popup)
    var mdiv = 'preview-modal', mcont = 'preview-modal-content', mclose = 'preview-modal-close';
    // Input parameters (fetch ids and data from cbcsvs and json descriptor)
    var ids    = [<%= params.map    { |p| "\"#{p['id']}\""       }.join(", ") %>];
    var names  = [<%= params.map    { |p| "#{p['name'].inspect}" }.join(", ") %>];
    var reqed  = [<%= params.select { |p| ! p['optional']        }.map { |u| "\"#{u['id']}\"" }.join(", ") %>];
    var files  = [<%= files.map     { |p| "\"#{p['id']}\""       }.join(", ") %>];
    var cbcsvs = [<%%= cbcsvs.map   { |c| "#{c.name.inspect}"    }.join(", ").html_safe %>];
    var cids   = [<%%= cbcsvs.map   { |c| "\"#{c.id}\""          }.join(", ").html_safe %>];
    var flags  = [<%= params.select { |p| p['type'] == 'Flag'    }.map { |u| "\"#{u['id']}\"" }.join(", ") %>];
<%% unk        = '?unknown?' %>
<%% maxNameLen = cbcsvs.map { |p| p.name }.max_by { |v| v.length }.length rescue nil %>
<%%# Replace unrecognized files with unk and "blanks" (i.e. the user wants no file present) with '' %>
<%% safeName   = lambda { |n| "\"#{n.nil? ? unk : ((n == ' ') ? '' : n.name)}\"" } %>
    var cfmap  = {
%   # Generate a list of the files associated to each cbcsv
<%% for cbcsv in cbcsvs %>
      <%% cn = "\"" + (cbcsv.name.gsub(/\"/,"\\\"") || unk) + "\"" %>
      <%% cbList = "#{cn.ljust(maxNameLen + 2)}" %>
      <%% assocFiles = cbcsvToFiles[ cn[1...-1] ].map{ |f| safeName.(f) }.join(", ") %>
      <%%= "#{cbList} : [#{assocFiles}],".html_safe %>
<%% end %>
    };
    var fileIdsToNames = {
%   # Give javascript access to the file id to name mapping
<%% for f in input_files %>
      <%%= "\"#{f.id}\" : #{f.name.inspect},".html_safe %>
<%% end %>
    };

    // Helper for extracting value lists
    var getVals = function( id, join ) {
      var vals = $('li.' + id + '.tsk-prm').find('.tsk-prm-in').map( function(){ return $(this).val(); } );
      // If not joining, leave
      if( ! join ){ return vals; }
      // Join the array if desired
      var out = "", n = vals.length;
      for( var j = 0; j < n; ++j){
        out += String(vals[j]) + ((j == n-1) ? '' : ', ');
      }
      return out;
    }

    // Handling for the single file case.
    // Here, there is only one file input and all files are automatically placed into it (immutably and automatically).
    // We wish to launch a task for each file, but if the file is a cbcsv, it should launch each of its subfiles as a task.
    // The preview table should reflect this.
    var single     = <%= single_file.nil? ? 'false' : "\"#{single_file['id']}\"" %>
    var singleName = (single == false) ? null : names[ ids.indexOf( single ) ]

    // Get which cbcsvs are in use, if any
    var activeCbcsvs = [], numIds = ids.length;
    if( single != false ){
      activeCbcsvs = cids.slice(0);
    } else {
      for( var i = 0; i < numIds; ++i ) {
        var id = ids[i];
        // Look at active file type parameters
        if( (isActiveParam( id ) || $.inArray(id, reqed) != -1) && $.inArray(id,files) != -1 ) {
          // Get filename; use id to determine type correctness
          var targets = getVals( id, false );
          var targ = String( targets[0] );
          if( $.inArray(targ,cids) != -1 ){
            activeCbcsvs.push( targ );
          }
        }
      }
    }

    // Helpers for the single file input case
    var allFiles = [] // Store a list of all the files, including those from the expanded cbcsv
    if( single != false ) {
      Object.keys( fileIdsToNames ).forEach( function(k) {
        var val = fileIdsToNames[ k ];
        if( $.inArray(k, cids) != -1) {
          var subfiles = cfmap[ val ];
          subfiles.map( function(v) { allFiles.push(v); } )
        } else {
          allFiles.push(val);
        }
      });
    }

    // Store any warnings
    var modalText = '';
    // Compute how many tasks are going to be generated
    var nTasks = 1, nCbcsvs = activeCbcsvs.length, lens = [];
    if( single != false ){
      nTasks = files.length - cbcsvs.length;
      Object.keys(cfmap).forEach( function (k) {
        nTasks += ( cfmap[k] ).length;
      });
    } else {
      for( var t = 0; t < nCbcsvs; ++t ) {
        // Note: here I prevent the code from breaking by taking the smallest active cbcsv
        // If someone attempts to launch with any of the sizes not matching, the after_form check will stop it, so don't worry
        // Hence, here, I give a warning to the user and choose the smallest size to ensure there is no error
        var plen = cfmap[ cbcsvs[ cids.indexOf(activeCbcsvs[t]) ] ].length; // id -> name -> filenames
        lens.push( plen );
        nTasks = (nTasks==1 || nTasks > plen) ? plen : nTasks;
        // Warning if the cbcsvs do not seem to be the right length
        if( lens.some(function(e,i,a){ return plen != e }) ) {
          modalText += "<font color=\"red\">Warning: cbcsvs with multiple unequal lengths detected</font><br><br>";
          break;
        }
      }
    }

    /* Helpers for generating preview tables */
    // CSS classes used
    var tableTextClass = "\"preview-table-text\"",  tableRowClass  = "\"preview-tr\"",         tableFillClass = "\"preview-table-fill\"";
    var tableBodyClass = "\"preview-table-hover\"", tableHeadClass = "\"preview-table-head\"", tableThClass   = "\"preview-th\"";
    var staticTblClass = "\"static-preview-table\"";
    // Adds a single row to a two-column table
    var addTableRow = function(prm, val) {
      return "<tr class="   + tableRowClass  + ">" +
               "<td class=" + tableTextClass + ">" + prm + "</td>" +
               "<td class=" + tableTextClass + ">" + val + "</td>" +
             "</tr>";
    }
    // Generate table for invariant parameters
    var generateStaticTable = function( singleFileCase = false, genericCase = false) {
      // Generate the title
      modalText += "<strong>Parameters " +
                     ((!singleFileCase && !genericCase) ? "for current task" : "that are constant across tasks") +
                   "</strong><br>";
      // Start the table
      modalText += "<table class=" + tableFillClass.slice(0,-1) + " " + staticTblClass.slice(1) + ">" + "<tbody class=" + tableBodyClass + ">";
      // Loop over possible entries (i.e. parameter ids)
      for( var i = 0; i < numIds; ++i ) {
        var id = ids[i];
        // Only consider active or required parameters
        if( isActiveParam( id ) || $.inArray(id, reqed) != -1 ) {
          // Skip files in the single file special case
          if( singleFileCase && ($.inArray(id, files) != -1) ) { continue; }
          // Extract the values associated to that parameter (flags are given true)
          var vals = ($.inArray(id, flags) != -1) ? "True" : getVals( id, true );
          // Ignore cbcsvs in the generic case (they will be in the dynamic table)
          if( genericCase && ($.inArray(vals, cids) != -1) ) { continue; }
          // Parameter name to put in the table
          var prmName = names[i];
          // For files, get their names instead of their ids
          vals = ($.inArray(id, files) == -1) ? vals : fileIdsToNames[vals]
          modalText += addTableRow(prmName, vals);
        }
      }
      // End the table
      modalText += "</tbody> </table> <br>";
    }
    // Generate table for inter-task varying parameters
    var generateDynamicTable = function( singleFileCase = true ) {
      // Add the title
      modalText += "<strong>Parameter values that change across tasks:</strong><br><br>";
      // Get parameters with cbcsv entries
      var iteratedParams = [];
      for( var i = 0; i < numIds; ++i ) {
        var id = ids[i];
        // Only consider active or required parameters
        if( isActiveParam( id ) || $.inArray(id, reqed) != -1 ) {
          // Extract the values associated to that parameter (flags are given true)
          var vals = ($.inArray(id, flags) != -1) ? "True" : getVals( id, true );
          // Grab the id & name if it is a cbcsv inside
          if( $.inArray(vals, cids) != -1 ){
            iteratedParams.push( [id, names[i]] );
          }
        }
      }
      // Now for the table head
      modalText += "<table class=" + tableFillClass + "><thead class=" + tableHeadClass + ">" +
                   "<tr class=" + tableRowClass + "><th class=" + tableThClass + ">Task</th>";
      if( singleFileCase ) { // Only one parameter is being iterated over
        modalText += "<th class=" + tableThClass + ">" + singleName + "</th>";
      } else { // Need to generate a column for each parameter with a cbcsv
        for( var i = 0; i < iteratedParams.length; ++i ) {
          modalText += "<th class=" + tableThClass + ">" + iteratedParams[i][1] + "</th>";
        }
      }
      // And now the table body
      modalText += "</tr></thead><tbody class=" + tableBodyClass + ">";
      // Generate a table row per task (i.e. per file)
      if( singleFileCase ) {
        for( var t = 0, k = 0; t < allFiles.length; ++t ) {
          // Skip rows that have a nil entry (they will not be launched)
          if( allFiles[t] == '' ){ continue; }
          // Otherwise, add a row for the task
          modalText += addTableRow( ++k, allFiles[t] );
        }
      } else { // generic case
        var ncols = nCbcsvs, nrows = nTasks;
        for( var i = 0; i < nrows; ++i ) {   // For each row,
          modalText += "<tr class=" + tableRowClass + "><td class=" + tableTextClass + ">" + i + "</td>";
          for( var j = 0; j < ncols; ++j ) { // generate a column per input
            // Associated id
            var currId  = iteratedParams[j][0];
            // Get cbcsv in that id
            var cbcsvId = getVals( currId, false )[0];
            // Get cbcsv object and its associated files for that id
            var cbcsvfs = cfmap[ fileIdsToNames[ cbcsvId ] ];
            // Add column to current row
            modalText += "<td class=" + tableTextClass + ">" + cbcsvfs[i] + "</td>";
          }
          modalText += "</tr>"; // End current table row
        }
      }
      // Close off the table
      modalText += "</tbody> </table> <br>";
    }

    ////* Actually draw the table now *////

    /* Special case: single task present (no cbcsvs, with more than one file input) */
    if( nTasks == 1 ) {
      generateStaticTable();
    }
    /* Special case: single File-type input parameter present (all files are placed into that input and a task is launched for each). */
    // Any cbcsv files present in that input are expanded to launch a task for each of their entries instead.
    else if( single != false ) {
      // Draw the static table, ignoring the cbcsvs among the inputs of the single file parameter
      generateStaticTable( true )
      // Draw the dynamic table, with a task (row) for each file in allFiles
      generateDynamicTable();
    }
    /* Generic case: otherwise, add static and dynamic sections to the preview */
    // Handles the single file multitask launch case or the cbcsv case
    else {
      // Generate table for static parameters, ignoring cbcsvs
      generateStaticTable( false, true );
      // Generate text for the dynamic parameters (i.e. with input cbcsvs)
      generateDynamicTable( false );
    }

    // Attach modal to preview button and display it
    $('.preview-div').append(
      '<div class="' + mdiv + ' modal">' +
        '<div class="' + mcont + '">' +
          '<span class="' + mclose + '">x</span>' +
          '<p>' + modalText + '</p>' +
        '</div>' +
      '</div>'
    );

    // Resize it so the height does not go offscreen
    $('.' + mcont).css('height', Math.round(window.innerHeight * 0.8) + 'px');
    // Attach closing listeners to it
    $('.' + mclose).click(function () {
      $('.' + mdiv).remove();  // Removal if 'x' is clicked
    });
    $('.' + mdiv).click(function () {
      $('.' + mdiv).remove();  // Removal if click outside
    });
    $('.' + mcont).click(function (event) {
      event.stopPropagation(); // Prevent removal if click inside
    });

  });

});
</script>

