
<%%-
#
# CBRAIN Project
#
# Copyright (C) 2008-2012
# The Royal Institution for the Advancement of Learning
# McGill University
#
# This program is free software: you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation, either version 3 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program.  If not, see <http://www.gnu.org/licenses/>.
#
-%>

<%%-
# NOTE: This is a working template generated from a descriptor:
# [Schema]         <%= schema['id'] %>
# [Schema version] <%= descriptor['schema-version'] %>
# [Tool]           <%= descriptor['name'] %>
# [Version]        <%= descriptor['tool-version'] || '?' %>
# See the CbrainTask Programmer Guide (CBRAIN Wiki) for a more complete picture
# of how CbrainTasks are constructed.
-%>
<%-
# NOTE: This template's weird indentation is there to try and make the
# generated code as legible as possible.
-%>

<%-
  # Parameter types
  params   = descriptor['inputs'].dup
  required = params.select { |i| ! i['optional'] }
  optional = params.select { |i|   i['optional'] }

  # Parameter groups and maps
  groups = descriptor['groups'].dup rescue []
  noGroups = (groups.length == 0)
  gIdToMbrs = groups.inject({}){ |m,v| m.merge( v["id"] => v["members"] ) }
  gIdToPrms = gIdToMbrs.map { |k,v| [k, params.select{ |p| v.include? p["id"] }] }.to_h

  # Single input file case
  files       = params.select { |i| i['type'] == 'File' }
  single_file = files.first if files.count == 1 && ! files.any? { |f| f['list'] }
-%>
<%% input_files = Userfile.find_all_by_id(params[:interface_userfile_ids]) rescue [] %>

<%-
  # Lambda for checking group membership
  whichGroup = lambda { |s| gIdToMbrs.select{ |v| gIdToMbrs[v].include? s }.first[0] rescue nil }
-%>

<%%#
  Generate a parameter label for HTML input with id +id+.
  +name+ corresponds to the tool parameter name to display,
  +optional+ indicates that the parameter is optional (or not) and
  +flag+ is the parameter's command-line flag if available.
%%>
<%% label = lambda do |id, name, optional: false, flag: nil| %>
  <label class="tsk-prm-lbl" for="<%%= id.to_la_id %>">
    <%%= name %>
    <%% if flag.present? %>
      (<code class="cmd-flag"><%%= flag %></code>)
    <%% end %>
    <%% unless optional %>
      <span class="required">*</span>
    <%% end %>
  </label>
<%% end %>

<%%#
  Generate a generic parameter input field with HTML id +id+ and name +name+.
  +type+ is the kind of input field to generate (text or hidden),
  +value+ is the input field's initial value,
  +optional+ indicates that the parameter is optional (and the name should not
  directly be placed on the tag) and
  +placeholder+ is the placeholder text to fill the input with while awaiting
  user input
%%>
<%% input = lambda do |id, name, type: 'text', value: nil, optional: false, placeholder: nil| %>
  <%% value = @task.params[name.to_sym] if name && value.nil? %>
  <input <%% if id %>
          id="<%%= id.to_la_id %>"
         <%% end %>
         class="tsk-prm-in"
         type="<%%= type %>"
         <%% if name %>
           <%%= optional ? 'data-name' : 'name' %>="<%%= name.to_la %>"
         <%% end %>
         <%% if value %>
           value="<%%= value %>"
         <%% end %>
         <%% if placeholder %>
           placeholder="<%%= placeholder %>"
         <%% end %>
  />
<%% end %>

<%%#
  Generate a list of inputs suitable for a list parameter with HTML id +id+
  and name +name+. +values+, +optional+ and +placeholder+ work similarly to
  input's corresponding arguments.
%%>
<%% input_list = lambda do |id, name, values: nil, optional: false, placeholder: nil| %>
  <%%
    values = @task.params[name.to_sym] if name && values.nil?
    values = values.is_a?(Enumerable) ? values.compact : [values].compact
    first = values.pop
  %>
  <ul class="tsk-prm-list">
    <li>
      <%%
        input.(id, name+"[]",
          value:       first,
          optional:    optional,
          placeholder: placeholder
        )
      %>
      <span class="tsk-prm-add ui-icon ui-icon-plus"></span>
    </li>
    <%% values.each do |value| %>
      <li>
        <%%
          input.(nil, name,
            value:       value,
            optional:    optional,
            placeholder: placeholder
          )
        %>
        <span class="tsk-prm-add ui-icon ui-icon-minus"></span>
      </li>
    <%% end %>
  </ul>
<%% end %>

<%%#
  Generate a fancy checkbox for flag or optional parameters with HTML +id+.
  If +name+ is given, a checkbox suitable for flag parameters is generated
  while one for optional arguments is generated otherwhise. The checkbox's
  initial state (checked or not) is +check+.
%%>
<%% checkbox = lambda do |id, name: nil, check: nil| %>
  <%%#
    FIXME for some obscure reason, naming the 'check' parameter 'checked'
    makes the first parameter (id) become nil regardless of the value passed
    in. This only seems to occur in the context of Rails' template renderer.
  %>
  <%%
    id    = name ? id.to_la_id : "tsk-prm-opt-#{id}"
    type  = name ? 'chk' : 'opt'
  %>
  <%% if name %>
    <%% check = @task.params[name.to_sym] if check.nil? %>
    <%%#
      As a checkbox's value is not sent if left unchecked, a hidden 'back' field
      sends the unchecked state is used to send. Rails overwrites this 'back'
      value with the checbox's when the checkbox is checked, as the checkbox is
      after the 'back' field.
    %>
    <input class="tsk-prm-chk-in"
           type="hidden"
           name="<%%= name.to_la %>"
           value="0"
    />
    <input class="tsk-prm-chk"
           type="checkbox"
           id="<%%= id %>"
           name="<%%= name.to_la %>"
           value="1"
           <%% if check %>
             checked="checked"
           <%% end %>
    />
  <%% else %>
    <input class="tsk-prm-opt"
           type="checkbox"
           id="<%%= id %>"
           <%% if check %>
             checked="checked"
           <%% end %>
    />
  <%% end %>
  <label class="tsk-prm-<%%= type %>-lbl" for="<%%= id %>">
    <span class="tsk-prm-<%%= type %>-icon ui-icon ui-icon-check"></span>
  </label>
<%% end %>

<%%#
  Generate a drop-down list for a set of +options+ (value, label pairs) with
  HTML id +id+ and name +name+.
  +nothing+ corresponds to the text displayed if +options+ is empty and
  +optional+ indicates if the parameter is optional (or not)
%%>
<%% dropdown = lambda do |id, name, options = [], nothing: '(Nothing to select)', optional: false| %>
  <%% value = @task.params[name.to_sym] if name %>
  <%%
    input.(id, name,
      type:     'hidden',
      value:    value,
      optional: optional
    )
  %>
  <div class="tsk-prm-sel">
    <%% if options.empty? %>
      <span class="tsk-prm-sel-lbl disabled">
        <%%= nothing %>
      </span>
    <%% else %>
      <span class="tsk-prm-sel-icon ui-icon ui-icon-triangle-1-s"></span>
      <span class="tsk-prm-sel-lbl">
        <%% if (pair = options.select { |o| o.first == value }.first) %>
          <%%= pair.last %>
        <%% end %>
      </span>
      <ul class="tsk-prm-sel-opt">
        <%% options.each do |value, label| %>
          <li data-value="<%%= value %>"><%%= label %></li>
        <%% end %>
      </ul>
    <%% end %>
  </div>
<%% end %>

<%%# Generate a checkbox for a parameter grouping %>
<%% groupCheckbox = lambda do |id, defaultChecked = false| %>
  <input class='group-toggler' 
    type='checkbox' 
    id='<%%= id %>_chk' 
    <%%= 'checked=\'checked\'' if defaultChecked %> 
  />
  <label for="<%%= id %>_chk"></label>
<%% end %>

<%%# Generate a parameter's description block for +desc+ %>
<%% description = lambda do |desc, isGroupMember = false| %>
  <span class="tsk-prm-desc">
    <%%= desc %><%%= "<br><br>".html_safe if isGroupMember %>
  </span>
<%% end %>

<%%# Give a short (up to +max+ characters) representation of +list+ %>
<%%
  short_repr = lambda do |list, max|
    str = list.map(&:to_s).join(', ')
    str.length <= max ? str : (str[0, max - 3] + '...')
  end
%%>

<%# Generate a complete HTML block for a given parameter +param+ -%>
<%- parameter = lambda do |param, isGroupMember = false| -%>
  <%-
    id    = param['id']
    type  = param['type'].downcase.to_sym
    opt   = !!(param['optional'] && type != :flag)
    list  = param['list']
  -%>
  <%-
    classes  = [ 'tsk-prm', type.to_s ]
    classes << 'list' if list
    classes << 'prm-grp-mbr' if isGroupMember
  -%>
    <%% id = '<%= id %>' %>
    <li class="<%%= id %> <%= classes.join(' ') %>">
      <%%
  <%- if type == :flag -%>
        # Flag input toggle
        checkbox.(id, name: id)

  <%- end -%>
        # Name/Label
        label.(id, %q{ <%= param['name'] %> },
  <%- if param['command-line-flag'] -%>
          optional: <%= param['optional'] %>,
          flag:     '<%= param['command-line-flag'] %>'
  <%- else -%>
          optional: <%= param['optional'] %>
  <%- end -%>
        )

  <%- if opt -%>
        # Optional parameter enable/disable toggle
        checkbox.(id)

  <%- end -%>
  <%- if type == :file -%>
    <%- if single_file -%>
        # Automatic single file input
        dropdown.(id, id,
          [], nothing: short_repr.(input_files.map(&:name), 65),
          optional: <%= opt %>
        )
    <%- elsif param['cbrain-file-type'] -%>
        # File input dropdown
        type = '<%= param['cbrain-file-type'] %>'.constantize rescue nil
        dropdown.(id, id,
          input_files
            .select { |f| f.is_a?(type) if type }
            .map    { |f| [ f.id.to_s, f.name ] },
          optional: <%= opt %>
        )
    <%- else -%>
        # File input dropdown
        dropdown.(id, id,
          input_files.map { |f| [ f.id.to_s, f.name ] },
          optional: <%= opt %>
        )
    <%- end -%>

  <%- elsif [ :string, :number ].include?(type) -%>
    <%-
      arg_width = [
        'optional',
        ('placeholder' if type == :number),
      ].compact.map(&:length).max + ':'.length
    -%>
    <%- if list -%>
        # Input field list
        input_list.(id, id,
    <%- else -%>
        # Input field
        input.(id, id,
    <%- end -%>
    <%- if type == :number -%>
          optional:    <%= opt.to_s %>,
          placeholder: '0.0'
    <%- else -%>
          optional: <%= opt.to_s %>
    <%- end -%>
        )

  <%- end -%>
  <%- if param['description'] -%>
        # Description
        description.(<<-'DESC',<%= isGroupMember %>)
          <%= param['description'] %>
        DESC
  <%- end -%>
     %> 
    </li>
<%- end -%>
<%# Generate HTML for a group -%>
<%- writeGroup = lambda do |group| -%>
  <%-
    # Get group parameters 
    id = group['id']
    name = group['name']
    groupDescription = group['description']
    groupParams = gIdToPrms[id]
    mbrs = gIdToMbrs[id]
    defaultChecked = group['one-is-required'] || required.any? { |p| mbrs.include? p["id"] }  
  -%>
  <div class="group <%= id %>"> 
    <%# Write group header %> 
    <div style="border-bottom: 2px solid #bbbbbb; padding-bottom: 2px;">
      <h3 style="border-width: 0px; margin: 0px; padding: 1px; padding-left: 0px;">
        <%= name %> <%% groupCheckbox.('<%= id %>',<%= defaultChecked %>) %>  
      </h3>
      <h5 style="font-size : 9.5pt; font-weight: normal; padding-top: 2px;" class="grp-desc"> 
        <%= groupDescription %> 
      </h5> 
    </div><%%= "<br>".html_safe %>
    <%# Write group parameters (required ones first) %>
    <%- groupParams.each { |p| parameter.(p, true) if required.any? { |r| p["id"]==r["id"] } } -%>
    <%- groupParams.each { |p| parameter.(p, true) if optional.any? { |t| p["id"]==t["id"] } } -%>
  </div>
  
<%- end -%>
<div class="task-params">
  <%- if params.empty? -%>
  <%= name %> has no parameters.
  <%- else -%>
  <ul>
%   # Write info for ungrouped parameters
    <%- for param in required do parameter.(param) if whichGroup.(param["id"]).nil? end -%>
    <%- for param in optional do parameter.(param) if whichGroup.(param["id"]).nil? end -%>
%   # Write info for grouped parameters
    <%- groups.each(&writeGroup) unless noGroups  -%>
  </ul>
  <%- end -%>
</div>

%# Style block for group toggling checkbox
<style>
.group-toggler {
    display: none; 
} 
.group-toggler + label {
  background-color: #fafafa;
  border: 1px solid #cacece;
  box-shadow: 0 1px 2px rgba(0,0,0,0.05), inset 0px -15px 10px -12px rgba(0,0,0,0.05);
  padding: 9px;
  border-radius: 3px;
  display: inline-block;
  position: relative;
  float: right;
  margin-right: 9pt;
}
.group-toggler + label:active, .group-toggler:checked + label:active {
  box-shadow: 0 1px 2px rgba(0,0,0,0.05), inset 0px 1px 3px rgba(0,0,0,0.1);
}
.group-toggler:checked + label {
  background-color: #0471b4;
  border: 1px solid #adb8c0;
  box-shadow: 0 1px 2px rgba(0,0,0,0.05), inset 0px -15px 10px -12px rgba(0,0,0,0.05), inset 15px 10px -12px rgba(255,255,255,0.1);
  color: #99a1a7;
}
.group-toggler:checked + label:after {
  content: '\2714';
  font-size: 14px;
  position: absolute;
  top: 0px;
  left: 3px;
  color: #ffffff;
}
</style>

<script type="application/javascript">
$(function () {
  "use strict";

  var parameters = $('.tsk-prm');

  /*
   * Remove the checked attribute of checkboxes and use their internal
   * state instead.
   */
  parameters.find("input[type='checkbox'][checked='checked']").each(function () {
    $(this)
      .removeAttr('checked')
      .prop('checked', true);
  });
  

  /*** Handle disables and requires relations between parameters ***/

% #
% # Make maps for which parameters disable/require each other
% #
% # Generates a map from id to [ids affected by the key id] for a given action name
% makeActorActionMap = lambda do |action|
%   params.inject({}){ |hmap,i| (res=i[action]) ? hmap.merge(i["id"]=>res) : hmap }
% end
% #
% # Generates a map from id to [ids affecting the key id] for a given action name
% makeReceiverActionMap = lambda do |action|
%   doesMap = makeActorActionMap.(action)
%   doneMap = doesMap.inject({}) do |map,(key,val)| # invert the relation above (active->passive)
%     for v in val do
%       if map[v].nil? then map[v] = [key] else map[v] << key end
%     end
%     map
%   end
% end
% #   
% # The actual maps: idIn -> [ids disabled/required by idIn]
% disabledBy_map = makeReceiverActionMap.("disables-inputs")
% requires_map = makeActorActionMap.("requires-inputs")
% #
% # Implement dynamic mutual exclusion within a group by pairwise adding to the disables map
% for group in groups
%   if group['mutually-exclusive']
%     for mId in group['members']
%       # Add all members of the group, except this one and ones already disabling it
%       alreadyDisables = lambda { |id| (disabledBy_map[mId] || []).include? id }
%       toAdd = group['members'].select{ |id| (id!=mId) && (! alreadyDisables.(id) ) }
%       disabledBy_map[mId] = ( (disabledBy_map[mId] + toAdd) rescue toAdd )
%     end
%   end
% end
% #
  /* Javascript dictionaries for names, disabledBy, and requires */
% # Produces a javascript version of the ruby map
% jsMapOf = lambda do |hmap|
%   n = hmap.size
%   hmap.each_with_index do |(k,v),i|
%    if v.is_a? Array
      <%= "\"#{k}\" : [" + v.map{ |s| "\"#{s}\"" }.join(',') + "]" + ((i == n-1) ? '' : ',') %>    
%    else
      <%= "\"#{k}\" : \"" + v + "\"" + ((i == n-1) ? '' : ',') %>      
%    end
%   end
% end
% #
  var namesMap = {
%   jsMapOf.( params.inject({}){ |hmap,x| hmap.merge( x["id"] => x["name"] ) } )
  }
  var requiresMap = {
%   jsMapOf.(requires_map)      
  };
  var disabledByMap = {
%   jsMapOf.(disabledBy_map)
  };

%# Generate JS functions for handling disables/requires
%#
  /*
   * Disables the targets of every active parameter within its disables list 
   * Also disables parameters whose required parameters are inactive, unless it 
   * is a mutual required relation.
   */
  function handleDisablesAndRequires() {

    // Function for disabling/enabling parameters
    var toggleFunctionality = function(target, shouldDisable, greyOutMsg){
      var lightGrey = '#d3d3d3'; // Firefox does not grey out disabled html elements        
      // Selector classes
      var toGreyOut = '.tsk-prm-in, .tsk-prm-opt-lbl, .tsk-prm-chk-lbl, .tsk-prm-sel';
      var toDisable = '.tsk-prm-in, .tsk-prm-opt, .tsk-prm-chk';
      var iconClasses = '.tsk-prm-opt-icon.ui-icon-check, .tsk-prm-sel-icon, .tsk-prm-add.ui-icon';
      // Disable and grey out text, file, & flag inputs, as well as their checkboxes
      target.find( toGreyOut ).css('background-color', shouldDisable ? lightGrey : '');      
      target.find( toDisable ).attr('disabled', shouldDisable);
      // For lists and files, toggle the ability to add more entries or change selections
      target.find('.tsk-prm-add.ui-icon,.tsk-prm-sel').css("pointer-events",shouldDisable?"none":"auto");
      // Erase the warning message: if one is needed it will be rewritten below
      target.find('.tsk-prm-lbl').find('label.disable-msg').remove();
      // Handle properties treated differently in each toggle case
      if( shouldDisable ){
        target.find( iconClasses ).addClass('ui-state-disabled'); // disable icons
        target.find('.tsk-prm-opt, .tsk-prm-chk').prop('checked', false); // uncheck checkboxes
        target.find('.tsk-prm-in').val(''); // wipe textbox input areas
        target.find('ul.tsk-prm-list').find('li').has('.ui-icon-minus').remove(); // rm list subitems
        // Write warning message
        var style = 'style="display: block; float: right; font-style: normal; font-weight: normal; ' + 
                    'font-size: 0.95em; color: rgb(255,50,50); margin-right: 17pt"';
        var msg = '<label class="disable-msg" ' + style + '>' + greyOutMsg  + '</label>';
        target.find('.tsk-prm-lbl').append( msg );
      }
      else {
        target.find( iconClasses ).removeClass('ui-state-disabled') // put icons in enabled state
      }
    } 

    // Function to map ids to names to make the messages a little prettier
    var idToName = function(x){ return namesMap[x]; }
    
    // Get combined keyset of potentially affected parameters
    var affectedIds = $.unique(Object.keys(disabledByMap).concat(Object.keys(requiresMap)));

    // Helper function that checks whether a given parameter is active
    var isActiveParam = function(id) {
      var targ = $( 'li.' + id + '.tsk-prm' );    
      if( targ.hasClass( 'flag' ) ){ // Flag case
        return targ.find('.tsk-prm-chk').prop('checked'); 
      }
      return targ.find('.tsk-prm-opt').prop('checked'); // Non-flag case
    }

    // Iterate over parameters, enabling and disabling as needed
    affectedIds.forEach( function( key ) {
      
      // Handle targeted disabling
      var disablers = [];
      if( key in disabledByMap ){
        var vals = disabledByMap[key], len = vals.length;
        // Look for disabling parameters
        for(var i = 0; i < len; ++i){
          if( isActiveParam(vals[i]) ){
            disablers.push(vals[i]);
          }
        }
      }

      // Handle parameter requirements (excludes parameters with mutual requirement)
      var missingReqs = [];
      if( key in requiresMap ){
        var vals = requiresMap[key], n = vals.length;
        for(var i = 0; i < n; ++i){      
          // If the required parameter is not checked (active) 
          if( ! isActiveParam(vals[i]) ){
            // If the required parameter does not require the current target parameter
            if( ( ! (vals[i] in requiresMap) ) || requiresMap[vals[i]].indexOf(key) == -1 ){ 
              missingReqs.push( vals[i] ); // Then add it to our set of missing requirements
            }
          }    
        } 
      }

      /* Perform disablings/enablings */
      // Disable the parameter is any of its disablers are on
      var target = $( 'li.' + key + '.tsk-prm' );
      if(disablers.length != 0){
        toggleFunctionality(target, true, "Disabled by " + disablers.map(idToName).join(", "));
      }  
      // Disable the parameter if it is missing any of its requirements
      else if(missingReqs.length != 0){
        toggleFunctionality(target, true, "Requires " + missingReqs.map(idToName).join(", "));
      }
      // Otherwise, enable the parameter
      else {
        toggleFunctionality(target, false, "");
      }

    });

  }

  /* Optional parameters */

  /* Clicking on the parameter's checkbox toggles the parameter's state */
  parameters.delegate('.tsk-prm-opt, .tsk-prm-chk', 'change activate.tsk-prm', function () {
    var opt   = $(this),
        param = opt.parent();

    /*
     * When an optional parameter is enabled, add its name attribute
     * (stored in a data-* field) to send them with the POST.
     */
    if (opt.prop('checked')) {
      param.find('.tsk-prm-in').each(function () {
        var name = $(this).data('name');

        /* Lists need to be sent with [] for proper server-side handling */
        if (param.hasClass('list')) name += '[]';

        $(this).attr('name', name);
      });

    /*
     * When an optional parameter is disabled, clear its value(s) and name
     * attribute.
     */
    } else {
      /* Main value and name attribute */
      param
        .find('.tsk-prm-in')
        .removeAttr('name')
        .val('');

      /* Display value for drop-down inputs */
      param
        .find('.tsk-prm-sel-lbl')
        .text('');

      /* Remove all extra inputs in input lists */
      param
        .find('.tsk-prm-list > li')
        .slice(1)
        .remove();
    }

    /* Check for disables/requires updates */
    handleDisablesAndRequires();

  });

  /* Changing a parameter's value automatically marks it as active */
  parameters.delegate('.tsk-prm-in', 'focus activate.tsk-prm', function () {
    $(this)
      .closest('.tsk-prm')
      .find('.tsk-prm-opt')
      .prop('checked', true)
      .trigger('activate.tsk-prm');
  });

  /* Activate optional parameters with default values */
  parameters.find(".tsk-prm-in[value]").trigger('activate.tsk-prm');

  /* Drop-down lists */

  /*
   * Clicking anywhere but the drop-down closes it without changing the
   * selection.
   */
  $('.task-params').click(function () {
    $(this)
      .find('.tsk-prm-sel-opt')
      .hide();
  });

  /* Clicking on the drop-down's label or icon toggles its visibility */
  parameters.delegate('.tsk-prm-sel', 'click', function (event) {
    event.stopPropagation();

    $(this)
      .children('.tsk-prm-sel-opt')
      .toggle();
  });

  /* Clicking on a drop-down item selects it */
  parameters.delegate('.tsk-prm-sel-opt > li', 'click', function () {
    var item  = $(this),
        param = item.closest('.tsk-prm');

    /* Set the backing input element's value */
    param
      .find('.tsk-prm-in')
      .val(item.data('value'))
      .trigger('activate.tsk-prm');

    /* Display the newly selected value in the drop-down's label */
    param
      .find('.tsk-prm-sel-lbl')
      .text(item.text());
  });

  /* Add/remove buttons for list parameters */

  /* Clicking on a '+' button adds a new value row and enables the parameter */
  parameters.delegate('.tsk-prm-add', 'click', function () {
    var name = $(this)
      .siblings('.tsk-prm-in')
      .attr('name');

    $(this)
      .closest('ul')
      .append(
        '<li>' +
          '<input ' +
            'class="tsk-prm-in" ' +
            'type="text" ' +
            'name="' + name + '" ' +
            'data-name="' + name + '" ' +
          '/> ' +
          '<span class="tsk-prm-rm ui-icon ui-icon-minus"></span>' +
        '</li>'
      )
      .siblings('.tsk-prm-opt')
      .prop('checked', true)
      .trigger('activate.tsk-prm');
  });

  /* Toggling groups */
  (function (fcn) {
    $('.group-toggler').each(fcn).change(fcn);
  })(function () {
    $(this)
      .parent() // header (3)
      .parent() // inner div
      .siblings('.prm-grp-mbr, .grp-desc')
      .toggle( $(this).prop('checked') );
  });

  /* Clicking on a '-' button removes the row */
  parameters.delegate('.tsk-prm-rm', 'click', function () {
    $(this)
      .closest('li')
      .remove();
  });
});
</script>
