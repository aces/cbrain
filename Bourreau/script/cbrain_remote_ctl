#!/usr/bin/env ruby

#
# CBRAIN Project
#
# Original author: Pierre Rioux
#
# $Id$
#

# This script is a wrapper that launches the normal Rails script/server,
# but with the added ability of receiving the content if the database.yml
# file in standard output before it does so. Also, once the server is
# started, the database.yml is deleted outright, closing a security hole.

# The command-line args are to be provided strictly in the order shown
# below, and all of them should be present (this is done simply so that
# this bash script is kept simple, as anyway this script is not meant
# to be started manually by users).


# To start the Rails app:
#
#   $0 start -e <environment> -p <port>
#
# which will result in reading the database.yml from stdin, installing
# it, executing this command
#
#   script/server -e <environment> -p <port> -b 127.0.0.1 -d
#
# and finally removing the database.yml file. Any database.yml file
# already present before doing all this will be backed up in
#
#     database.yml.cbrain_remote_bak.
#
# Note that if stdin contains nothing (zero bytes) the current
# database.yml file will be used, or the script will restore and use
# the backup file 'database.yml.cbrain_remote_bak'.


# To stop the Rails app:
#
#   $0 stop
#
# which will result in killing the rails app.


require 'rubygems'
require 'active_support'
require File.dirname(__FILE__) + '/../lib/cbrain_file_revision.rb' # ugly
require File.dirname(__FILE__) + '/../lib/ssh_master.rb' # ugly


#########################
# S U B R O U T I N E S #
#########################

# Usage
def usage(basename)
    puts "Usage: #{basename} [-R host -H http_port -D db_port] start -e <environment> -p <port>\n" +
         "       #{basename} [-R host -H http_port -D db_port] stop"
    Kernel.exit(10)
end

# Fatal error message
def fatal(message)
    puts message
    Kernel.exit(20)
end

# Establish a SSH tunnel to a secondary host
# where this script will be effectively run.
def tunnel_to_secondary_host(host, http_port, db_port, args)
  myuid   = Process.uid
  mylogin = Etc.getpwuid(myuid).name
  proxymaster = SshMaster.find_or_create(mylogin,host,22)
  proxymaster.add_tunnel(:forward, http_port.to_i, 'localhost', http_port.to_i)
  proxymaster.add_tunnel(:reverse,   db_port.to_i, 'localhost',   db_port.to_i)
  unless proxymaster.start('Proxy')
    puts "Cannot start proxy master channel to '#{host}'."
    Kernel.exit(20)
  end
  myscript = __FILE__
  myscript = (Pathname.getwd + myscript).to_s if myscript !~ /^\//
  proxymaster.remote_shell_command_writer("bash -c \"ruby #{myscript} #{args.join(" ")} 2>&1\"" ) do |fh|
    fh.write(STDIN.read) unless args.size == 1 && args[0] == 'stop'
  end
  if args.size == 1 && args[0] == 'stop'
    proxymaster.stop
  end
  Kernel.exit(0)
end

# Run-time paths
cwd      = Dir.getwd
basename = $PROGRAM_NAME
fullprog = basename =~ /^\// ? basename : cwd + "/" + basename

# Rails-specific paths
rails_home = fullprog.sub(/\/script\/.+$/,"")
pidfile    = "#{rails_home}/tmp/pids/mongrel.pid"

# Automatic redirection to a secondary host
if ARGV.size > 6 && ARGV[0] == '-R' && ARGV[2] == '-H' && ARGV[4] == '-D'
  remhost   = ARGV[1]
  httpport  = ARGV[3]
  dbport    = ARGV[5]
  ARGV.shift(6)
  tunnel_to_secondary_host(remhost, httpport, dbport, ARGV)
  exit 0
end

# Check usage
usage(basename) if ARGV.size !=1 && ARGV.size != 5    # 1 or 5 args!

# To help diagnose problems, print Ruby's version.
puts "You are using Ruby #{RUBY_VERSION}"

#############################################################
# Stop
#############################################################

if ARGV.size == 1
    usage(basename) if ARGV[0] != "stop"
    fp = File.open(pidfile,"r") rescue nil
    if fp
        pid = fp.read.to_i
        fp.close
        Process.kill("TERM", pid)
        puts "Bourreau Stopped"
        Kernel.exit(0)
    end
    fatal "Could not find/open PID file '#{pidfile}'."
end

#############################################################
# Start
#############################################################

usage(basename) if ARGV[0] != "start" || ARGV[1] != "-e" || ARGV[3] != "-p"
if File.exist?(pidfile)
  pid = File.read(pidfile).to_i
  # TODO make check for running process platform-independent
  fatal("The Rails app seems to be running already (PID=#{pid}). Kill it first.") if File.exist?("/proc/#{pid}")
  File.unlink(pidfile) rescue true
end

# Check arguments
environment = ARGV[2]
port        = ARGV[4].to_i
fatal("Environment argument must be 'production', 'development' or 'test'") unless
   environment =~ /^(production|development|test)$/
fatal("Port argument must be a number greater than 1024 and less than 65530") unless
   port > 1024 && port < 65535

db_yml_text = STDIN.read || ""
db_file     = rails_home + "/config/database.yml"
db_file_bak = rails_home + "/config/database.yml.cbrain_remote_bak"

# Install or restore database.yml if necessary
db_exists  = File.exist?(db_file)
bak_exists = File.exist?(db_file_bak)
blank_yml  = db_yml_text !~ /\S/

if blank_yml #  blank? use what db.yml is already here
  if db_exists
    # nothing to do
  elsif bak_exists
    File.rename(db_file_bak,db_file)
  else
    fatal("Could not find a database.yml file for the Rails application!")
  end
else # db text is provided to us
  if db_exists
    File.rename(db_file,db_file_bak) # will crush existing bak file
  end
  # Optional: change stuff in it, depending on the environment
  unless ENV['CBRAIN_FRONTEND_HOSTNAME'].nil? || ENV['CBRAIN_FRONTEND_HOSTNAME'] =~ /^\s*$/
    db_yml_text.sub!(/hostname:\s*\S+/,"hostname: #{ENV['CBRAIN_FRONTEND_HOSTNAME']}")
  end
  File.open(db_file,"w") { |fh| fh.write(db_yml_text) }
end

# This environment variable holds the path to a status
# file created by the server 'cbrain_mongrel_rails' at startup;
# it will contain the word 'STARTED' or 'STOPPED'. This will happen
# even if the server crashes early on.
status_file = rails_home + "/tmp/pids/mongrel.status"
ENV["CBRAIN_SERVER_STATUS_FILE"] = status_file
File.unlink(status_file) rescue true # Make sure it's not there at all

# Start the server
Dir.chdir(rails_home) do
  # Note that the options for 'cbrain_mongrel_rails' are the same as
  # for 'mongrel_rails', but they are different from 'script/server'
  # (in particular, -b becomes -a).
  cmd = "script/cbrain_rails_server server thin -d -p #{port} -e #{environment} -b 127.0.0.1 -P #{pidfile}"
  system(cmd) # the -d will start it in background
end

# Wait for the status file to appear; it will appear whether or not the
# server was able to properly start.
start_check = Time.now
while start_check > (Time.now - 120)  # check for two minutes, at most
  sleep 1
  break if File.exists?(status_file)
end

# If we were provided with a database.yml, we need
# to wait a bit and delete it once the server has read
# it.
if ! blank_yml
  File.unlink(db_file) rescue true
end

# Return a message to indicate to our calling context
# whether or not the server started.
status_message = File.read(status_file) rescue "FAILED\n"
if status_message =~ /STARTED/i # see Bourreau's validation.rb
  puts "Bourreau Started."
else
  puts "Bourreau Failed."
  puts "Here are the last 100 lines of the server's log:"
  Dir.chdir(rails_home) do
    system("tail -100 log/server.log")
  end
end
Kernel.exit(0)

