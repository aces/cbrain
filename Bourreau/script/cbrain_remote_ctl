#!/usr/bin/env ruby

#
# CBRAIN Project
#
# Copyright (C) 2008-2021
# The Royal Institution for the Advancement of Learning
# McGill University
#
# This program is free software: you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation, either version 3 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program.  If not, see <http://www.gnu.org/licenses/>.
#

# This script is a wrapper that launches the normal Rails server,
# but with the added ability of receiving the content of the database.yml
# file in standard output before it does so. Also, once the server is
# started, the database.yml is deleted outright, closing a security hole.
#
# This script it NOT usually executed by a human, instead it is
# invoked by the Portal when trying to start or stop a Bourreau.
#
# The command-line args are to be provided strictly in the order shown
# below, and all of them should be present (this is done simply so that
# this bash script is kept simple, as anyway this script is not meant
# to be started manually by users).
#
#
# To start the Rails app:
#
#   $0 start -e <environment>
#
# which will result in reading the database.yml from stdin, installing
# it, executing this command
#
#   puma --config config/puma.rb
#
# and finally removing the database.yml file. Any database.yml file
# already present before doing all this will be erased.
#
#
# To stop the Rails app:
#
#   $0 stop
#
# which will result in killing the rails app.
#
#
# To start a console:
#
#   $0 console -e <environment>

# IMPORTANT DEVELOPER NOTICE:
#
# This script is written in plain standard Ruby with NO
# access to Rails and other ActiveSupport helpers. Therefore
# you can't invoke things like ".present?" and ".blank?" etc.
# The reason for this is to make this script boot up as
# quickly as possible.

#########################
# S U B R O U T I N E S #
#########################

# Usage
def usage(basename)
    puts "Usage: #{basename} start -e <environment>\n" +
         "       #{basename} stop\n" +
         "       #{basename} console -e <environment>"
    Kernel.exit(10)
end

# Fatal error message
def fatal(message)
    puts message
    Kernel.exit(20)
end

# Run-time paths and names of host and program
basename   = $PROGRAM_NAME.sub(/.*\//,"") # that constant is provided by Ruby
curhost    = `hostname -s`.strip
rails_home = __dir__.sub(/\/Bourreau\/script.*$/,"/Bourreau")

# Make sure we're at the base of the app
Dir.chdir(rails_home)

# Rails-specific paths.
# Alongside the PID file, we maintain the hostname where
# the Bourreau was previously started.
db_file    = "config/database.yml"
pidfile    = "tmp/pids/server.pid"
pidhost    = "#{pidfile}.hostname"

# Values from previous 'start' operation
prevpid    = File.read(pidfile).to_i rescue 0
prevhost   = (File.read(pidhost) rescue "").strip

# To help diagnose problems, print Ruby's version.
puts "You are using Ruby #{RUBY_VERSION}"
if RUBY_VERSION =~ /^1\.[0-8]/
  puts "Warning! This Ruby version seems to be way too old. Maybe your environment wasn't initialized properly?"
end

# Check usage
usage(basename) if ARGV.size != 1 && ARGV.size != 3 # 1 or 3 args!


#############################################################
# STOP
#############################################################

if ARGV.size == 1
  usage(basename) if ARGV[0] != "stop"
  if prevhost != curhost
    prevhost = '(unknown)' if prevhost == "" # prettier fatal message
    prevpid  = '(unknown)' if prevpid  == 0  # prettier fatal message
    fatal("Could not stop Bourreau app, it was last started on host #{prevhost} as PID #{prevpid}, and we are on host #{curhost}")
  end
  fatal("Could not find/open PID file '#{pidfile}'.") if prevpid == 0
  Process.kill("TERM", prevpid)
  puts "Bourreau Stopped"
  File.unlink(pidhost) rescue nil
  Kernel.exit(0)
end


#############################################################
# ARGUMENT CHECKS FOR OTHER MODES (start or console)
#############################################################

# start -e env
# console -e env
mode        = ARGV[0] # 'start' or 'console'
environment = ARGV[2]

usage(basename) if ARGV[1] != "-e"
usage(basename) unless mode =~ /^(start|console)$/
fatal("Environment argument must be 'production' or 'development'") unless
  environment =~ /^(production|development)$/

# Check for existing PID file
# and cleanup if necessary
if mode == "start" && prevpid > 0

  # If it was started on a different login node, we can't do anything else
  if prevhost != "" && prevhost != curhost
    fatal("The Rails app seems to be running already on a different host, #{prevhost} as PID #{prevpid}")
  end

  # The 'ps' command below echoes back the PID if the process exists,
  # and it happens to work on both Linux and MacOS.
  exists = `ps -p #{prevpid} -o pid=`
  if exists.include?(prevpid.to_s) # this is a substring match
    fatal("The Rails app seems to be running already as PID #{prevpid}.")
  end
  # OK so the process seems to be dead, let's just clean up.
  File.unlink(pidfile) rescue true
  File.unlink(pidhost) rescue true
end

# In 'start' mode, we get the content of the database.yml
# from STDIN stream. In 'console' mode, the content is already
# installed in place by a separate 'cat' command issued
# by the portal (see in bourreau.rb).
db_yml_text = mode == 'start' ? STDIN.read : ""
blank_yml   = db_yml_text !~ /\S/

if blank_yml # blank? use what db.yml is already here
  if ! File.exist?(db_file)
    fatal("Could not find a database.yml file for the Rails application!")
  end
  db_yml_text = File.read(db_file)
end

# Substitute most recently created DB socket filename
sockfiles = Dir.glob("tmp/sockets/db.*.sock")
fatal("Could not find a DB socket in tmp/sockets/db.*.sock") if sockfiles.size == 0
sockfiles.sort! { |sock_a,sock_b| File.mtime(sock_a) <=> File.mtime(sock_b) } # order by time
db_sockfile = sockfiles.pop.to_s # remove the last, which is the most recent
db_yml_text.sub!(/socket:.*/,"socket: #{rails_home}/#{db_sockfile}")

# Write it back
File.open(db_file,"w") { |fh| fh.write(db_yml_text) }

# Remove all older socket files
sockfiles.each { |f| File.unlink(f) rescue nil }


###########################################
# CONSOLE START
###########################################

if mode == 'console'
  puts "\nBourreau Console Starting on #{curhost}."
  start_success = system("script/rails", "console", environment) # this will BLOCK
  puts "\nBourreau Console Exiting on #{curhost}."
  File.unlink(db_file) rescue true
  Kernel.exit(start_success ? 0 : 10) # all done
end


###########################################
# BOURREAU START
###########################################

# Rename log files when they are too big
date_extension       = Time.now.strftime("%Y-%m-%d")
start_log_file       = "log/server_start.log"
environment_log_file = "log/#{environment}.log"
if File.exists?( start_log_file ) && File.size( start_log_file ) > 1_048_576
  File.rename(start_log_file, start_log_file.sub(/\.log$/,"_#{date_extension}.log"))
end
if File.exists?( environment_log_file ) && File.size( environment_log_file ) > 1_048_576
  File.rename(environment_log_file, environment_log_file.sub(/\.log$/,"_#{date_extension}.log"))
end

# Start the server
ENV["RAILS_ENV"] = environment  # puma's mode of operation is passed through an env var
# puma_wait_wrapper is a custom bash program that starts puma
# and waits to make sure it booted properly
start_success = system("script/puma_wait_wrapper")

# If we were provided with a database.yml, we need
# delete it once the server has read it.
if (! blank_yml)
  File.unlink(db_file) rescue true
end

# Return a message to indicate to our calling context
# whether or not the server started.
if start_success
  puts "Bourreau Started." # This string is used by the Portal controller!
  File.open(pidhost,"w") { |fh| fh.write curhost } # write back current hostname
  Kernel.exit(0)
end

puts "Bourreau application failed to start properly."
#if File.exists?(start_log_file)
#  puts "Here are the last 200 lines of the server's log:"
#  system("tail -200 '#{start_log_file}'")
#else
#  puts "No server log file found to help you out of this one :-("
#end
Kernel.exit(10)

